(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{373:function(a,t,e){a.exports=e.p+"assets/img/2024-05-23-20-18-17.d6024cf8.png"},374:function(a,t,e){a.exports=e.p+"assets/img/2024-05-23-20-18-29.163e9437.png"},375:function(a,t,e){a.exports=e.p+"assets/img/2024-05-23-20-18-40.940a581b.png"},376:function(a,t,e){a.exports=e.p+"assets/img/2024-05-23-20-19-14.c04eb2bc.png"},377:function(a,t,e){a.exports=e.p+"assets/img/2024-05-23-20-19-20.6673753f.png"},509:function(a,t,e){"use strict";e.r(t);var r=e(15),n=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("原文："),t("a",{attrs:{href:"https://blog.langchain.dev/langgraph-multi-agent-workflows/",target:"_blank",rel:"noopener noreferrer"}},[a._v("LangGraph: Multi-Agent Workflows"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v('很高兴地介绍 langgraph 强大的用例 - 多代理工作流。在本博客中，我们将涵盖：\n"multi-agen  多代理"是什么意思？')]),a._v(" "),t("p",[a._v("为什么“multi-agent 多代理”工作流程很有用？")]),a._v(" "),t("p",[a._v("使用 LangGraph 进行多代理工作流程的三个具体示架构")]),a._v(" "),t("p",[a._v("使用多代理工作流程构建在 LangGraph 之上的第三方应用的两个示例（GPT-Newspaper 和 CrewAI）")]),a._v(" "),t("p",[a._v("与其他框架（Autogen 和 CrewAI）的比较")]),a._v(" "),t("h2",{attrs:{id:"什么是-multi-agent-多代理协同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-multi-agent-多代理协同"}},[a._v("#")]),a._v(" 什么是“multi-agent”（多代理协同）？")]),a._v(" "),t("p",[a._v("当我们谈论“multi-agent”时，我们指的是由 LLM 语言模型驱动的多个独立行动者 Agent 以特定方式连接在一起。")]),a._v(" "),t("p",[a._v("每个代理都可以拥有自己的提示词，LLM底层模型，调用工具和其他自定义代码，以便与其他代理最好地协作。\n这意味着在考虑不同的多代理工作流时有两个主要考虑因素：\n什么是多个独立 Agent 代理？\n这些Agent 代理如何连接？")]),a._v(" "),t("p",[a._v("这种思维非常适合图表示，比如 langgraph 提供的那种。在这种方法中，每个代理都是图中的一个节点，它们的连接被表示为一条边。控制流由边管理，并通过向图的状态添加信息进行通信。")]),a._v(" "),t("p",[a._v("注意：这里一个非常相关的概念是状态机的概念，我们明确将其称为认知架构的一类。从这种角度看，独立的代理节点变成了状态，而这些代理如何连接则是转移矩阵。由于状态机可以被视为带标签的有向图，我们将以相同的方式思考这些事情。")]),a._v(" "),t("p",[a._v("（译者注：langgraph 提供 muti-agent 的底层抽象，类似构建类似有向无环图，把每个代理当作一个节点，每个代理的连接当作节点之间的边，这样基于图-节点的关系该概念去构建任务代理架构）")]),a._v(" "),t("h2",{attrs:{id:"多代理设计的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多代理设计的好处"}},[a._v("#")]),a._v(" 多代理设计的好处")]),a._v(" "),t("p",[a._v("如果一个代理无法正常工作，那么为什么多代理会有用呢？\n分组工具/责任可以带来更好的结果。一个代理在专注于一项任务时更有可能成功，而不是必须从数十种工具中进行选择。\n分开的提示可以提供更好的结果。每个提示都可以有自己的说明和少量示例。每个代理甚至可以由一个单独微调的LLM来驱动！\n有助于开发的概念模型。可以评估和改进每个代理，而不会破坏更大的应用程序。")]),a._v(" "),t("p",[a._v("多代理设计允许您将复杂问题分解为可由专门代理和LLM程序针对的可处理单位的工作单元。")]),a._v(" "),t("h2",{attrs:{id:"multi-agent-架构1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multi-agent-架构1"}},[a._v("#")]),a._v(" Multi-agent （架构1）")]),a._v(" "),t("p",[a._v("我们已经向 langgraph 仓库添加了三个独立的多代理工作流示例。每个示例对上述两个问题的答案略有不同，我们将在突出显示示例时进行讨论。重要的是要注意，这三个示例只是我们可以突出显示的可能示例中的几个 - 几乎可以肯定还有其他示例存在，我们期待看到社区会提出什么样的示例！\n多智能体协作\nCode links: 代码链接:\nPython\nJS")]),a._v(" "),t("p",[a._v("在这个例子中，不同的代理在共享的消息草稿（其实就是共享的思考链上下文）上进行协作。这意味着他们中的任何一个所做的工作都对另一个可见。这样做的好处是其他代理可以看到所有的个别步骤。这样做的缺点是有时候过于冗长和不必要地传递所有这些信息，有时候只需要一个代理的最终答案。我们称之为协作，因为这个消息草稿是共享的性质。")]),a._v(" "),t("h3",{attrs:{id:"每个独立-agent-代理边界如何定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#每个独立-agent-代理边界如何定义"}},[a._v("#")]),a._v(" 每个独立 Agent 代理边界如何定义？")]),a._v(" "),t("p",[a._v("在这种情况下，独立代理实际上只是一个单一的LLM调用。具体来说，它们是一个特定的提示模板（以特定系统消息的特定方式格式化输入）加上一个LLM调用。")]),a._v(" "),t("h3",{attrs:{id:"这些代理如何连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这些代理如何连接"}},[a._v("#")]),a._v(" 这些代理如何连接？")]),a._v(" "),t("p",[a._v("这里是这些代理如何连接的可视化展示：")]),a._v(" "),t("p",[t("img",{attrs:{src:e(373),alt:""}})]),a._v(" "),t("p",[a._v("添加图片注释，不超过 140 字（可选）")]),a._v(" "),t("p",[a._v("控制状态转换的主要因素是 router 路由器，但它是一个基于规则的路由器，因此相当简单。基本上，在每次LLM调用之后，它会查看输出。如果调用了工具，则调用该工具。如果没有调用工具，而LLM回应“FINAL  ANSWER”，则返回给用户。否则（如果没有调用工具，而LLM没有回应“FINAL ANSWER”），则转到另一个LLM。\n(译者注：第一种模式其实就是常见的 reAct 基础上增加了几个 LLM ，每个 LLM 都可以看到共同思考的上下文链路，中间的路由就是根据关键字正则匹配调用哪些工具。 但纯 reAct只有一个 LLM 系统提示词，而多 Agent 的每个 LLM 是有自己独立的系统提示词，甚至可以是独立微调的 LLM )")]),a._v(" "),t("h2",{attrs:{id:"agent-supervisor-代理中介者模式-架构2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agent-supervisor-代理中介者模式-架构2"}},[a._v("#")]),a._v(" Agent Supervisor 代理中介者模式（架构2）")]),a._v(" "),t("p",[a._v("Examples: 示例:\nPython\nJS")]),a._v(" "),t("p",[a._v("在这个例子中，多个代理连接在一起，但与上面的情况相比，它们不共享一个共享的草稿板。相反，它们有各自独立的草稿板，然后它们的最终响应被附加到一个全局草稿板中。")]),a._v(" "),t("h3",{attrs:{id:"每个独立-agent-代理边界如何定义-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#每个独立-agent-代理边界如何定义-2"}},[a._v("#")]),a._v(" 每个独立 Agent 代理边界如何定义？")]),a._v(" "),t("p",[a._v("在这种情况下，独立代理是一个 LangChain 代理。这意味着它们有自己的个别提示，LLM，和工具。当被调用时，不仅仅是一个单独的 LLM 调用，而是 AgentExecutor 的运行。")]),a._v(" "),t("h3",{attrs:{id:"这些代理如何连接-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这些代理如何连接-2"}},[a._v("#")]),a._v(" 这些代理如何连接？")]),a._v(" "),t("p",[t("img",{attrs:{src:e(374),alt:""}})]),a._v(" "),t("p",[a._v("添加图片注释，不超过 140 字（可选）")]),a._v(" "),t("p",[a._v("代理中介者负责将路由到各个代理。")]),a._v(" "),t("p",[a._v("这样，中介者也可以被视为是其他代理的代理！\n（译者注：其实就是使用一个专门的 LLM 作为中介者，接受用户信息，再根据信息转发到适合的专用 Agent 上。这样的好处就是每个特定领域的 Agent 聚焦自己擅长的事情，这里既可以是提示工程的优化，也可以是 llm 微调。）")]),a._v(" "),t("h2",{attrs:{id:"hierarchical-agent-teams-分层代理团队-架构3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hierarchical-agent-teams-分层代理团队-架构3"}},[a._v("#")]),a._v(" Hierarchical Agent Teams 分层代理团队（架构3）")]),a._v(" "),t("p",[a._v("Examples: 示例:\nPython\nJS")]),a._v(" "),t("p",[a._v("这与上面的示例类似，但现在节点中的代理实际上是其他 langgraph 对象本身。这比使用 LangChain AgentExecutor 作为代理运行时提供了更多的灵活性。我们称之为分层团队，因为子代理可以被视为团队的一部分。\n每个独立 Agent 代理边界如何定义？")]),a._v(" "),t("p",[a._v("现在这里的“其他”代理是指 langgraph 代理子节点。")]),a._v(" "),t("h3",{attrs:{id:"这些代理如何连接-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#这些代理如何连接-3"}},[a._v("#")]),a._v(" 这些代理如何连接？")]),a._v(" "),t("p",[t("img",{attrs:{src:e(375),alt:""}})]),a._v(" "),t("p",[a._v("添加图片注释，不超过 140 字（可选）")]),a._v(" "),t("p",[a._v("一个中介代理，再加一个代理组将它们连接起来。\n（译者注： 其实就是在架构2 的基础上，对下面的代理再次分层，将同类任务的代理组成一个 team。比如写文章的任务：可以由网络检索 Agent、信息筛选Agent、文章段落构思 Agent、文章撰写 Agent、文章检查 Agent等组合成一个团队。每个 Agent 又能调用自己的工具，这种适合非常大型的 Agent 协同）")]),a._v(" "),t("h2",{attrs:{id:"第三方应用程序案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三方应用程序案例"}},[a._v("#")]),a._v(" 第三方应用程序案例")]),a._v(" "),t("p",[a._v("As  part of this launch, we're also excited to highlight a few applications  built on top of LangGraph that utilize the concept of multiple agents.\n作为这一发布的一部分，我们也很高兴地强调了一些构建在 LangGraph 之上并利用多个代理概念的应用程序。")]),a._v(" "),t("h3",{attrs:{id:"gpt-newspaper-gpt-报纸"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpt-newspaper-gpt-报纸"}},[a._v("#")]),a._v(" GPT-Newspaper GPT-报纸")]),a._v(" "),t("p",[a._v("这是由   GPT-研究者团队推出的新项目。GPT-报纸是一款创新的自主代理，旨在根据用户偏好创建个性化报纸。GPT-报纸通过利用人工智能的力量根据个人口味和兴趣策划、撰写、设计和编辑内容，彻底改变了我们消费新闻的方式。该架构由六个专门的子代理组成。有一个关键步骤  - 一个作家 <> 评论循环，可以增加一个有益的循环。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(376),alt:""}})]),a._v(" "),t("p",[a._v("添加图片注释，不超过 140 字（可选）")]),a._v(" "),t("h3",{attrs:{id:"crew-ai-example-机组人工智能示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#crew-ai-example-机组人工智能示例"}},[a._v("#")]),a._v(" Crew AI example 机组人工智能示例")]),a._v(" "),t("p",[a._v("Joao Moura 利用 CrewAI、LangChain 和 LangGraph 的优秀示例，自动化检查电子邮件并创建草稿的过程。 CrewAI 协调自主 AI 代理，使它们能够高效地协作和执行复杂任务。\nThe graph in this example looks like the below:\n这个例子中的图表如下所示：")]),a._v(" "),t("p",[t("img",{attrs:{src:e(377),alt:""}})]),a._v(" "),t("p",[a._v("添加图片注释，不超过 140 字（可选）")]),a._v(" "),t("h2",{attrs:{id:"其他框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他框架"}},[a._v("#")]),a._v(" 其他框架")]),a._v(" "),t("p",[a._v("LangGraph 不是第一个支持多代理工作流的框架。这些框架之间的主要区别在于它们引入的心智模型和概念。")]),a._v(" "),t("h3",{attrs:{id:"autogen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autogen"}},[a._v("#")]),a._v(" Autogen")]),a._v(" "),t("p",[a._v("Autogen  可能是第一个多代理框架。LangGraph 和 Autogen 之间心智模型的最大区别在于代理的构建。LangGraph  更倾向于一种方法，您可以明确定义不同的代理和转换概率，更喜欢将其表示为图形。Autogen  将其框架更多地视为“对话”。我们认为这种“图形”框架使其更直观，并为构建更复杂和有主见的工作流提供更好的开发者体验，您可以真正控制节点之间的转换概率。它还支持那些不被“对话”明确捕获的工作流。")]),a._v(" "),t("p",[a._v("Autogen 和 LangGraph 之间的另一个关键区别是 LangGraph 完全集成到 LangChain 生态系统中，这意味着您可以充分利用所有 LangChain 集成和 LangSmith 可观性。")]),a._v(" "),t("h3",{attrs:{id:"crewai-机组人工智能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#crewai-机组人工智能"}},[a._v("#")]),a._v(" CrewAI 机组人工智能")]),a._v(" "),t("p",[a._v("另一个我们想要强调的关键框架是  CrewAI。CrewAI 最近已经成为创建多智能体“团队”的流行方式。与 LangGraph 相比，CrewAI  是一个更高级的框架。事实上，我们正在积极与 CrewAI 团队合作，将 LangGraph 集成到 CrewAI 中！我们认为 CrewAI  已经达到了令人惊叹的更高级别的 DevEx，我们希望支持这一点。\n（译者注：以上3 种架构均提供了官方源码，但 Multi-agent 架构不止上面示例的 3种，实际情况需要根据业务场景和模型能力去适配，比如在分层代理的时候是不是可以部分组共享上下文草稿，部分不共享等。在实际种，代理层级多会导致执行时间非常长，这种情况下用于决策的路由代理可以微调，或者用小模型等进行加速。）")]),a._v(" "),t("p",[a._v("以上来源 langchain blog 官方原文，在个人理解基础上有所增删减。")])])}),[],!1,null,null,null);t.default=n.exports}}]);