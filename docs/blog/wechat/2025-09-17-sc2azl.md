---
title: 大模型的函数调用是你想象的这样吗
date: 2025-09-17 14:18:00
type: post
blog: true
render_type: html
description: 大模型的函数调用是你想象的这样吗
tags:
- 微信公众号
- 混沌福王
---

<p style="visibility: visible;"><span leaf="" style="visibility: visible;">函数调用有原生和非原生两种，在 2024 年，大多开源模型不支持原生的函数调用，2025 年新出的模型普遍都支持 openai 类的</span><span leaf=""  style="visibility: visible;">&nbsp;Function call。</span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;">最近尝试用&nbsp;</span><span leaf="" style="visibility: visible;">Qwen3 235B A22B</span><span leaf="" style="visibility: visible;">&nbsp;的原生函数调用，调试了很多场景，发现在原生的 Function call 下，指令遵守能力很弱，甚至不如之前 qwen 2.5 的提示词函数调用。然后尝试转之前的非原生方案，发现效果反而更好。在 2024 年应用 qwen 2.5 的时候，当时研究过一些 paper，原生函数调用会限制模型的自由，从而降低性能。看起来这个问题在开源模型中至今（2025 年下旬）还是是有。为此，继续深入研究了这个问题。</span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><span textstyle="" style="font-size: 20px; font-weight: bold; visibility: visible;">函数调用的底层</span></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p  style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><ul style="list-style-type: disc; visibility: visible;" class="list-paddingleft-1"><li style="font-weight: bold; visibility: visible;"><p  style="visibility: visible;"><span leaf="" style="visibility: visible;"><span textstyle="" style="font-weight: bold; visibility: visible;">原生函数调用</span></span></p></li></ul><p  style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p  style="visibility: visible;"><span leaf="" style="visibility: visible;">函数调用是由大量意图识别、</span><span leaf=""  style="visibility: visible;">工具调用</span><span leaf="" style="visibility: visible;">训练 + 约束解码两个步骤组成。前者通常是大量的训练保证模型准确的理解意图，并调用工具。但由于概率的存在，模型不可能保证 100% 的完整 json 。 原生函数调用能 100 % 输出 json 靠约束解码算法的功劳 ，这个算法会在 LLM每次 token 产生候选词的时候，对那些不符合 json格式的候选者设置负无限大的概率，从而强制模型跳过那些不合法的 json token。</span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><ul style="list-style-type: disc; visibility: visible;" class="list-paddingleft-1"><li style="font-weight: bold; visibility: visible;"><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><span textstyle="" style="font-weight: bold; visibility: visible;">基于提示词的函数调用</span></span></p></li></ul><p style="visibility: visible;"><span leaf="" style="visibility: visible;"><br style="visibility: visible;"></span></p><p style="visibility: visible;"><span leaf="" style="visibility: visible;">与原生调用不同，提示工程使用并不依赖于模型任何内置的功能。它是通过精心设计的提示词来引导任何具备强大指令遵循能力的LLM完成工具调用任务。</span></p><p><span leaf=""><br></span></p><p><span leaf="">通过提示词构造类似的 prompt，核心思路是告诉模型它的角色、可用的工具（函数），以及必须遵循的输出格式。</span></p><p><span leaf=""><br></span></p><p><span leaf="">一个典型的提示词结构如下：</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf="">你是一个智能助手，可以调用外部工具来完成用户的请求。</span></code><code><span leaf="">根据用户的需求，从以下可用工具列表中选择一个或多个最合适的工具。</span></code><code><span leaf="">你必须严格按照指定的JSON格式返回你的响应，不要添加任何额外的解释或对话。</span></code><code><span leaf=""><br></span></code><code><span leaf=""><span class="code-snippet__comment"># 可用工具列表</span></span></code><code><span leaf="">[</span></code><code><span leaf="">&nbsp; {</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"name"</span>:&nbsp;<span class="code-snippet__string">"get_current_weather"</span>,</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"获取指定城市的实时天气信息。"</span>,</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"parameters"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"object"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"properties"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"location"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"string"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"城市名称，例如：北京"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; },</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"unit"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"string"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"enum"</span>: [<span class="code-snippet__string">"celsius"</span>,&nbsp;<span class="code-snippet__string">"fahrenheit"</span>],</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"温度单位"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; },</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"required"</span>: [<span class="code-snippet__string">"location"</span>]</span></code><code><span leaf="">&nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; },</span></code><code><span leaf="">&nbsp; {</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"name"</span>:&nbsp;<span class="code-snippet__string">"send_email"</span>,</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"向指定收件人发送邮件。"</span>,</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"parameters"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"object"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"properties"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"recipient"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"string"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"收件人的电子邮件地址"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; },</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"subject"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"string"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"邮件主题"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; },</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"body"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"string"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"description"</span>:&nbsp;<span class="code-snippet__string">"邮件正文内容"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; },</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"required"</span>: [<span class="code-snippet__string">"recipient"</span>,&nbsp;<span class="code-snippet__string">"subject"</span>,&nbsp;<span class="code-snippet__string">"body"</span>]</span></code><code><span leaf="">&nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; }</span></code><code><span leaf="">]</span></code><code><span leaf=""><br></span></code><code><span leaf=""><span class="code-snippet__comment"># 输出格式</span></span></code><code><span leaf="">请将你的思考过程和最终要调用的工具封装在一个JSON对象中，并用&nbsp;<span class="code-snippet__string">```json ... ```</span>&nbsp;包裹。</span></code><code><span leaf="">格式如下：</span></code><code><span leaf="">{</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"thought"</span>:&nbsp;<span class="code-snippet__string">"这里是你对用户需求的分析过程，说明你为什么选择这个工具以及如何填充参数。"</span>,</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"tool_calls"</span>: [</span></code><code><span leaf="">&nbsp; &nbsp; {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"function"</span>:&nbsp;<span class="code-snippet__string">"工具名称"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"arguments"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"参数1"</span>:&nbsp;<span class="code-snippet__string">"值1"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"参数2"</span>:&nbsp;<span class="code-snippet__string">"值2"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; ]</span></code><code><span leaf="">}</span></code><code><span leaf=""><br></span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><h4 ><b><span leaf=""><span textstyle="" style="font-size: 17px;">模型返回 JSON ，再由程序解析</span></span></b></h4><p><span leaf=""><br></span></p><p><span leaf="">当模型接收到上述提示后，它会根据指令生成一个JSON字符串。例如，针对上面的用户请求，模型可能会返回：</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf=""><span class="code-snippet__punctuation">{</span></span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__attr">"thought"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__string">"用户有两个任务：查询天气和发送邮件。我需要先调用`get_current_weather`获取上海的天气，然后将天气信息作为邮件内容，再调用send_email工具发送邮件。"</span><span class="code-snippet__punctuation">,</span></span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__attr">"tool_calls"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__punctuation">[</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__punctuation">{</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__attr">"function"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__string">"get_current_weather"</span><span class="code-snippet__punctuation">,</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__attr">"arguments"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__punctuation">{</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__attr">"location"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__string">"上海"</span><span class="code-snippet__punctuation">,</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__attr">"unit"</span><span class="code-snippet__punctuation">:</span>&nbsp;<span class="code-snippet__string">"celsius"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__punctuation">}</span></span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__punctuation">}</span></span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__punctuation">]</span></span></code><code><span leaf=""><span class="code-snippet__punctuation">}</span></span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf="">应用程序的后端接收到这个包含JSON的字符串后，需要进行解析和处理。这个过程通常分为两步：提取和解析。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-weight: bold;">1. 提取JSON字符串</span></span></p><p><span leaf="">程序需要从模型的完整响应中准确地抽取出被 json ... &nbsp;包裹的内容。这可以通过正则表达式或简单的字符串分割来实现。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-weight: bold;">2. 解析JSON并执行调用</span></span></p><p><span leaf="">拿到纯净的JSON字符串后，程序会尝试将其转换成可操作的对象（如Python中的字典）。</span></p><p><span leaf=""><br></span></p><p><span leaf="">由于模型概率的存在，基于提示词的函数调用无法保证100%，但通常能通过防御性解析，避免大多数错误，在极端情况解析识别，再由 LLM 重新生成。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-size: 20px;font-weight: bold;">性能对比</span></span></p><p><span leaf=""><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">原生的函数调用一定是最佳的吗？</span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">一项早期研究 &nbsp;</span><span leaf="" >https://arxiv.org/abs/2408.02442 表明</span><span leaf="">，更宽松的提示通常会产生更好的结果， JSON&nbsp;</span><span leaf="" >约束解码</span><span leaf="">模式在大多数情况下表现较差，其次是 FRI（</span><span style="color: rgb(31, 35, 40);font-family: -apple-system, &quot;system-ui&quot;, &quot;Segoe UI&quot;, &quot;Noto Sans&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;;font-size: 16px;font-style: normal;font-variant-ligatures: normal;font-variant-caps: normal;font-weight: 400;letter-spacing: normal;orphans: 2;text-align: left;text-indent: 0px;text-transform: none;widows: 2;word-spacing: 0px;-webkit-text-stroke-width: 0px;background-color: rgb(255, 255, 255);text-decoration-thickness: initial;text-decoration-style: initial;text-decoration-color: initial;display: inline !important;float: none;" ><span leaf="">通过提示词来指导模型）、NL to Format （先输出</span><span leaf="">自然语言，再转成格式化</span><span leaf="">）。</span></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><section style="text-align: center;" nodeleaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72oxW9D2Eh86X0GIMiaOz4qXUmmgE5mJQ7CUTfia0L9wtf2ibZczwyCzA5g/640?wx_fmt=png&amp;from=appmsg#imgIndex=0" class="rich_pages wxw-img js_img_placeholder wx_img_placeholder"     type="block"    src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72oxW9D2Eh86X0GIMiaOz4qXUmmgE5mJQ7CUTfia0L9wtf2ibZczwyCzA5g/640?wx_fmt=png&amp;from=appmsg#imgIndex=0" _width="677px" style="width: 677px !important; height: 810.519px !important;" alt="Image"></section><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="">但这项研究是针对去年和前年的模型，得出</span><span leaf="">格式的限制，尤其是约束解码（JSON 模式），会阻碍推理能力。这和从笔者的长期对开源模型的体验中的感受一致，<span textstyle="" style="font-weight: bold;">基于提示词的效果比原生函数调用更好。</span></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-weight: normal;">由于 2025 年，新的开源模型普遍针对原生函数调用做了优化，于是继续深入调查了一些研究。</span></span></p><p><span leaf=""><br></span></p><p><b ><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">其中找到 ProlLM函数调用最新排行榜（2025/08），</span><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">它测试了完全相同的模型在分别使用原生函数调用和提示工程方法时的性能表现。</span></b></p><p><b ><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></b></p><section style="text-align: center;" nodeleaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72Ik38OVl26FUbRPHnVSWcz6qAKFwwcqsT7SmVVX5vEKamn6jjNqYDvw/640?wx_fmt=png&amp;from=appmsg#imgIndex=1" class="rich_pages wxw-img js_img_placeholder wx_img_placeholder"     type="block"    src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72Ik38OVl26FUbRPHnVSWcz6qAKFwwcqsT7SmVVX5vEKamn6jjNqYDvw/640?wx_fmt=png&amp;from=appmsg#imgIndex=1" _width="677px" style="width: 677px !important; height: 155.459px !important;" alt="Image"></section><p><b ><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></b></p><section style="text-align: center;" nodeleaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK726dKsTibmz7wJdOqPrWa6aWyuGHM5jsyR2x5DjeEbLCUn5KsTxLoAQNw/640?wx_fmt=png&amp;from=appmsg#imgIndex=2" class="rich_pages wxw-img js_img_placeholder wx_img_placeholder"     type="block"    src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK726dKsTibmz7wJdOqPrWa6aWyuGHM5jsyR2x5DjeEbLCUn5KsTxLoAQNw/640?wx_fmt=png&amp;from=appmsg#imgIndex=2" _width="677px" style="width: 677px !important; height: 144.803px !important;" alt="Image"></section><p><b ><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></b></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="">函数准确率（Function Accuracy）：衡量模型是否选择了正确的函数来响应用户请求。</span></p><p><span leaf="">参数正确性（Argument Correctness）：衡量在选择了正确的函数之后，模型为其提供的参数是否准确无误。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-weight: bold;">Deepseek V3 和 sonnet 4.0在使用提示工程（Prompting）方法时，其函数准确率均高于其使用原生函数调用（Function Calling）。</span></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">但在&nbsp;</span><span leaf="">&nbsp;Berkeley Function-Calling Leaderboard 平台，原生函数调用分数明显比基于提示词的高。</span></p><p><span leaf=""><br></span></p><section style="text-align: center;" nodeleaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72x43GREFwwRiaLRGHiajsQTmCaJSny2OIhkZibEO3QHwYWqLgqZtzibTS7Q/640?wx_fmt=png&amp;from=appmsg#imgIndex=3" class="rich_pages wxw-img js_img_placeholder wx_img_placeholder"     type="block"    src="https://mmbiz.qpic.cn/sz_mmbiz_png/UtlXZ9UDt5icXdvSyicgLs5xlSBshDbK72x43GREFwwRiaLRGHiajsQTmCaJSny2OIhkZibEO3QHwYWqLgqZtzibTS7Q/640?wx_fmt=png&amp;from=appmsg#imgIndex=3" _width="677px" style="width: 677px !important; height: 269.546px !important;" alt="Image"></section><p><span leaf=""><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p ><span leaf="">说明<span textstyle="" style="font-weight: bold;">基于提示词的函数调用版本依赖提示词的设计水平。</span></span></p><p ><span leaf=""><br></span></p><p ><span leaf=""><span textstyle="" style="font-size: 20px;font-weight: bold;">提示实现的优化方案</span></span></p><p ><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">最早期的做法是通过提示词构造 json 格式，常见的有</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf="">你是Agent ，任务是 xx</span></code><code><span leaf=""><br></span></code><code><span leaf="">请按格式返回如下json 用``` json ``` 包裹</span></code><code><span leaf="">``` json</span></code><code><span leaf="">{</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"function"</span>:&nbsp;<span class="code-snippet__string">"edit_file"</span>,</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"arguments"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"file"</span>:&nbsp;<span class="code-snippet__string">"app.py"</span>,</span></code><code><span leaf="">&nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"changes"</span>:&nbsp;<span class="code-snippet__string">"add error handling"</span></span></code><code><span leaf="">&nbsp; }</span></code><code><span leaf="">}</span></code><code><span leaf="">```</span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">但 json 有一个很大的问题，就是转义符号的处理非常困难，比如双引号的value 内部出现大段代码的时候，很容易出现内部双引号，这个时候模型需要额外添加转义符 / 。在推理任务复杂的情况，很容易导致 json 解析失败，从而浪费时间。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">多项研究表明，像 JSON 这样的受限生成格式会降低模型在复杂推理任务上的性能。</span></p><p><span leaf=""><br></span></p><p><span leaf="">XML 工具调用消除了这些限制，同时保持了结构和可解析性：</span></p><p ><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">edit_file</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">file</span></span><span class="code-snippet__tag">&gt;</span>app.py<span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">file</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">changes</span></span><span class="code-snippet__tag">&gt;</span>add comprehensive error handling with logging<span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">changes</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf=""><span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">edit_file</span></span><span class="code-snippet__tag">&gt;</span></span></code></pre></section><p ><span leaf=""><br></span></p><p ><span leaf=""><br></span></p><p ><span leaf="">在 &nbsp;Morph Apply 进行的测试中，XML 工具调用始终优于 JSON：</span></p><p><span leaf="">畸形工具调用减少 30%, 代码质量得分提高 25%，生成速度提高 40% （约束开销更小）, 错误恢复率提高 60%。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">在 claude 官方推荐的自定义格式也是 xml , sonent 模型对 xml 有着天然的大量训练。</span><span leaf="">Cursor 的部分版本系统提示显示大量使用 XML 进行工具调用：</span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf=""><br></span></code><code><span leaf=""><span class="code-snippet__operator">&lt;</span>summarization<span class="code-snippet__operator">&gt;</span></span></code><code><span leaf="">If you see a section&nbsp;<span class="code-snippet__keyword">called</span>&nbsp;"&lt;most_important_user_query&gt;", you should treat that query&nbsp;<span class="code-snippet__keyword">as</span>&nbsp;the&nbsp;<span class="code-snippet__keyword">one</span>&nbsp;<span class="code-snippet__keyword">to</span>&nbsp;answer,&nbsp;<span class="code-snippet__keyword">and</span>&nbsp;ignore previous&nbsp;<span class="code-snippet__keyword">user</span>&nbsp;queries. If you&nbsp;<span class="code-snippet__keyword">are</span>&nbsp;asked&nbsp;<span class="code-snippet__keyword">to</span>&nbsp;summarize the conversation, you MUST&nbsp;<span class="code-snippet__keyword">NOT</span>&nbsp;use&nbsp;<span class="code-snippet__keyword">any</span>&nbsp;tools, even if they&nbsp;<span class="code-snippet__keyword">are</span>&nbsp;available. You MUST answer the "&lt;most_important_user_query&gt;" query.</span></code><code><span leaf=""><span class="code-snippet__operator">&lt;/</span>summarization<span class="code-snippet__operator">&gt;</span></span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">笔者最近测试了 XML 替代传统的 json以及原生函数调用，在 qwen3 的表现明显更佳。这里的理解是： xml 属于 html 一类标签语言，天然被大量训练。且 xml 解决转义问题，即使出现标签闭合等格式问题，也能通过程序自动发现和修复，比 json的转义处理更简单，在越复杂的任务越复杂，XML 的优势就越大。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-size: 20px;font-weight: bold;">原生函数调用其他问题</span></span></p><p><span leaf=""><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">在是否选择推理（比如 r1、 qwen3-</span><span leaf="">Thinking</span><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">等）模型选择的时候，我们经常会为性能和时间两者之间纠结，在纯性能上，推理模型的工具调用能力高很多。但目前开源模型的推理时间不能像 o3 这样控制思考的预算，导致一些简单的任务，模型思考过久，从而浪费时间。</span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;"><br></span></p><p><span leaf="" style="color:rgba(0, 0, 0, 0.9);font-size:17px;font-family:&quot;mp-quote&quot;, &quot;PingFang SC&quot;, system-ui, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;line-height:1.6;letter-spacing:0.034em;font-style:normal;font-weight:normal;">而非推理模型，比如 v3、&nbsp;</span><span leaf="">Qwen3-Instruct 等，则容易陷入因缺乏思考导致工具调用不准的问题。</span></p><p><span leaf=""><br></span></p><p><span leaf="">通常原生的函数调用能支持让模型先思考，再返回工具。</span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf="">{</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"role"</span>:&nbsp;<span class="code-snippet__string">"assistant"</span>,</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"content"</span>:&nbsp;<span class="code-snippet__string">"我来为您查询北京的天气信息。"</span>,</span></code><code><span leaf="">&nbsp;&nbsp;<span class="code-snippet__string">"tool_calls"</span>: [</span></code><code><span leaf="">&nbsp; &nbsp; {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"id"</span>:&nbsp;<span class="code-snippet__string">"call_abc123"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"type"</span>:&nbsp;<span class="code-snippet__string">"function"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"function"</span>: {</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"name"</span>:&nbsp;<span class="code-snippet__string">"get_weather"</span>,</span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="code-snippet__string">"arguments"</span>:&nbsp;<span class="code-snippet__string">"{</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">location</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">:&nbsp;</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">北京</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">,&nbsp;</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">unit</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">:&nbsp;</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">celsius</span><span class="code-snippet__string"><span class="code-snippet__subst">\"</span></span><span class="code-snippet__string">}"</span></span></code><code><span leaf="">&nbsp; &nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; &nbsp; }</span></code><code><span leaf="">&nbsp; ]</span></code><code><span leaf="">}</span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf="">如上，</span><span leaf="">"我来为您查询北京的天气信息。"本身是模型在工具调用前思考的内容，我们可以通过提示词控制这个思考的长度。但目前测试&nbsp;</span><span leaf="">Qwen3 235B A22B 不是很稳定，其他开源模型也类似（qwen3-coder 表现更好）。</span></p><p><span leaf=""><br></span></p><p><span leaf="">但我们始终无法把&nbsp;</span><span leaf="">content 当作思考的过程，因为它本身是需要渲染给用户的内容。</span><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">通过 XML ，我们能精确控制推理时间、显示内容以及工具调用，并且强制思考过程，降低了原生函数调用意图识别的不稳定。</span></p><p><span leaf=""><br></span></p><section class="code-snippet__fix code-snippet__js"><ul class="code-snippet__line-index code-snippet__js"><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="code-snippet__js" ><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">reason</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf="">一步一步分析，不控制在 30-50字之间</span></code><code><span leaf=""><span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">reason</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">content</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf="">最终显示给用户的内容</span></code><code><span leaf=""><span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">content</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf=""><span class="code-snippet__tag">&lt;</span><span class="code-snippet__tag"><span class="code-snippet__name">tool_call</span></span><span class="code-snippet__tag">&gt;</span></span></code><code><span leaf="">&nbsp;工具调用</span></code><code><span leaf="">&nbsp;<span class="code-snippet__tag">&lt;/</span><span class="code-snippet__tag"><span class="code-snippet__name">tool_call</span></span><span class="code-snippet__tag">&gt;</span></span></code></pre></section><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><span textstyle="" style="font-size: 20px;font-weight: bold;">结</span></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">任何特定格式的有效性都与模型的训练数据高度相关。开发者社区的经验表明，不同模型对结构化数据的处理能力差异显著 ，例如，某些模型（如Claude系列）被观察到能出色地处理XML，而其他模型可能因为其训练语料中包含了大量的Web API和代码库，而对JSON更为熟悉 (reddit社区反馈小模型对 json 更好)。</span></p><p><span leaf=""><br></span></p><p><span leaf="">这意味着不存在一个普遍“最优”的格式。对于工程负责人而言，在选择基础模型时，其对不同结构化数据格式的熟练度应成为一个关键的评估标准，且特定的业务数据可能和格式相关（由于 LLM 的 xml 训练大量是代码）。所以，仅仅依赖通用基准测试是不够的，必须进行针对特定格式和用例的内部评估。</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf="">——</span></p><p><span leaf="">相关参考</span></p><p><span leaf=""><br></span></p><p><span leaf="">https://arxiv.org/abs/2408.02442(约束格式会降低性能)</span></p><p><span leaf="">https://www.prollm.ai/leaderboard/function-calling(函数调用榜)</span></p><p><span leaf="">https://gorilla.cs.berkeley.edu/leaderboard.html</span></p><p><span leaf="">https://docs.morphllm.com/guides/xml-tool-calls<a class="wx_topic_link" topic-id="mfo1i0vg-sstah8" style="color: #576B95 !important;"  href="javascript:;">#how</a>-cursor-uses-xml-tool-calls</span></p><p><span leaf="">https://www.reddit.com/r/LocalLLaMA/comments/1i5k5qw/best_format_for_structured_output_for_smaller/</span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p style="display: none;"><mp-style-type ></mp-style-type></p>

<hr />

<div class="original-link" style="margin-top: 20px; padding: 10px; background-color: #f8f8f8; border-radius: 6px;">
  <p style="margin: 0; font-size: 14px;">⚠️ 本文自动同步自公众号，排版可能异常，其包含图片、视频内容可能无法正常显示和播放。</p>
  <p style="margin: 5px 0 0; font-size: 14px;">原文链接：<a href="https://mp.weixin.qq.com/s/Oj43dok0VcnEcVEtT4SYFQ" target="_blank" rel="noopener noreferrer">点击查看微信公众号原文</a></p>
</div>
