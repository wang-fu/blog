
举个简单例子：在前端编程语言中提供了 模块导入方式：`import module1 from 'src/components/HelloWorld'`。这里的 module1 是确定的，静态的，代码维护者一眼就知道它具体的组件。

但前端的灵活性，通常也能动态编写：


``` javascript
const magic = generateMagic(props.whom);
const module1 import('src/components/${magic}/HelloWorld');
```

很显然，动态的逻辑，需要人脑了解 generateMagic 上下文全部知识，深入变量背后的细节，去预演一遍代码的执行过程，最后得到结果。显然，我们的大脑并不擅长这的计算，通常这是调试程序需要做的事情。

上面是一个模块导入的例子，对于组件层面的编写，动态判断更是一件可维护性非常差的过程。

但组件动态逻辑编写在很多场景是必要的逻辑：
``` javascript

<component1 v-if="xx==1"/>
<component2 v-if="xx==2"/>
<component3 v-if="xx==3"/>
<component4 v-if="xx==4"/>
```

渲染经常会充斥这样的条件判断，甚至更复杂难懂：
``` javascript

<component1 v-if="xx==1 && yy!==2"/>
<component2 v-if="xx==2 && yy == 3"/>
<component3 v-if="xx==3 && yy == 2 && dd === 44"/>
<component4 v-if="xx==4 && dd = 88"/>
... more
```

遇到这样的代码，最有耐心的人也会焦躁。当然，有些人说通过 vue 动态组件的语法改写：

``` javascript
<!-- current 改变时组件也改变 -->
<component :is="current()"></component>

const current = () => {
  if (xx ==1 && !==2) {
    return component1
  }
  if (xx==2 && yy == 3) {
    return component2
  }
  if (xx==3 && yy == 2 && dd === 44) {
    return component3
  }
  if (xx==4 && dd = 88) {
    return component4
  }
}

```

看上去会好了许多，代码维护中最怕的是变化，但又不可避免，component 其设计核心是意图将`变化的部分封装起来`。

但这仅仅是框架层面，DSL 语言层面对代码表达层的一种优化，代码复杂的核心仍然没有变化，维护者对代码理解的成本换了一地方，就是这个叫 current 的函数。

理论上业务代码的最低复杂度无法改变，但能够合适的转移，这是提高可维护性的关键。我们建立一个代码阅读均等的理想值，每个人阅读一个函数的成本为 1，每次打开仓库需要阅读 X 个函数，阅读 N 次的成本是 N * X。

如果团队项目成员有 M 个人，总的阅读成本是 (N * X) * M , 随着函数量的不断扩张、阅读此次数更多、协作人数增加，复杂度会越来越高。

我们说过每个函数不管你怎么优化，其最低复杂度是由业务逻辑决定的，不可能消失。但每个成员阅读多少个函数，则是由分工及代码结构决定。

比如开发者要找到子组件 3 渲染的结果其路径是：
 `入口函数——mian组件——子组件1——子组件2——子组件函数2——子组件3`

从目前的结构上，开发者必须要经过上面路径才能确定子组件 3 的渲染值，其复杂度是整条路径需要理解的函数成本 X 。子组件 3 阅读更多，这位同学的成本也更多（忽略记忆带来的熟练程度）。

怎么从代码结构上降低其成本呢？在不影响整体业务表达的情况下，我们可以根据这些组件、函数的使用频率，调整组件、函数在架构中的路径位置，同时配合调整成员分工，让每个人聚焦在各自频率最高的逻辑上，让其他不属于自己业务的函数需要被理解和阅读的次数降低到 0。

```
入口函数——mian组件——子组件1——子组件2——子组件函数2
                ——子组件3
                
```

理论上，根据业务合理的分工、合理的重新划分代码组件、函数路径，每个人需要阅读无关自己本次任务的的成本降低到最低 0 （理想模型）。

用新的调整重新计算以上复杂度：X1= 必要阅读的函数、N：阅读次数（和之前保持不变）、M：成员数

(N * X1) * 1


优化后的结果是，即时代码的整体数量在不断增加，但因为合理的划分了代码结构与函数分布，每个人仍然只需要理解自己的 X1 逻辑，而合理分工又让成员增加，不会影响自己负责的模块。这样代码整体复杂度，等于自己关心的这部分 X1 函数数量。


站在只有一位开发同学的角度，收益也非常明显，假设函数1是经常不需要去理解的逻辑、底层的逻辑，而把这样一种逻辑放在整条理解链路的必经之路，开发同学自己每次都要理解这个函数。

结，我们证明了，代码的业务最低复杂度虽然不可能变化和消失，但可以将这些复杂的东西转移到不同的地方，大部分人在开发中不需要关注，从而降低成本。
