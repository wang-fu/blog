---
title: 抽象随想
date: 2022-06-06 23:22:00
type: post
blog: true
description: 抽象是屏蔽细节、提高生产力的重要方式，也是人类非常高级的大脑活动，比如，你向他人描述你一天的行为
tags:
    - 抽象
    - 随想
    - 思维
---

抽象是屏蔽细节、提高生产力的重要方式，也是人类非常高级的大脑活动，比如，你向他人描述你一天的行为：起床刷牙洗脸、走出家门，打车，等待司机、让司机直走10公里，右拐 2 公里，再左转 直行 3 公里，最后看到一个停车场停车，进行机场检票，上飞机，等待，下飞机，再次打车，让司机直走10公里，右拐 2 公里，再左转 直行 3 公里到一个红色酒店，进入里面，检票，等待自己的分享时间，轮到自己分享后，再分享抽象模型，xxx, 最后和其他嘉宾就餐，住酒店。（更多细节略…）



如果用代码实现这一过程，没有抽象的行为就是把每个细节逐一实现一边，然后被人（包括自己）阅读这段代码，如果你不厌其烦的讲述这些细节。第二天，我们继续用代码实现类似的其他过程，别人打听的时候，又需要反复讲述这个过程。



我们如果对一天抽象呢？ 起床准备、去机场、去酒店、分享会、住酒店。 也可以说是并列的，在家时间、交通中、分享中、甚至是更简单出差、在家。取决于你向听你讲故事的人展示哪些关键信息，不同的抽象会导致不同的组合，而抽象的不同于编程中所谓提取重复，重复提取是机械性的，抽象是把大量细节根据知识和预期进行归类，然后定义类别和类别之间的关系。



对于写代码也是这样，如果只是机械考虑具体实现、那么大量实现就如同每次开车左拐右拐一样，将全部的细节，无整理的暴露在开发的眼中，而我们阅读代码的时间往往多于写代码的时间，再你阅读的时候，我们需要有一个结构的指引，就如同安排一天的行程，先吃饭，在出行，再开会，但却无关里面的细节。而需要细节的地方，我们再从抽象好的概念中深入，比如出行是怎么实现的，打车还是飞机等，只需要时才去关心它，这样在阅读和理解代码会更加快速。



想象一些你阅读一个没有目录，只有页码的书，每次你只知道这个页码讲了什么，那个页码讲了什么，想要前后不断跳转阅读不同内容，你则需要细细翻阅每个关联的页数，而如果一本有良好目录的书，你只需要记住一些内容大概的章节名/标题，也就是局部内容的抽象，那阅读书本则更有效率（通常技术、工具类书更需要前后反复查阅）。



计算机发展史，本身就是抽象史，指令集结构、汇编、高级语言，这从低到高，都是对计算机的抽象，如没有抽象，你的软件实现需要关注每一个细节，和其他人沟通也费劲，内存存取、cpu 计算等。而不同的抽象则，本身是一种设计，它表达了抽象者的理念，比如 c 语言中把数据和代码的概念分离，而 lisp 则认为代码即数据等，那意味着你用这两种不同高级语言，实现代码的思维不一样。



抽象是人类思维的高级活动，这里的细节太多、从常见的设计模式、架构如MVC 、到具体的业务，比如多个用户提供一个编写文章的工具、这里可以业务上抽象用户管理系统、文本编辑系统、文章管理系统等等。实际上到可以到更细，比如编辑系统，内部的行为和操作，可以只读模式，编辑模式，更近一步编辑模式还可以有文本编辑、图形编辑，数据、行为、服务等等。这些东西，根本没有哪本书可以教你（可以给你概念，但给不了抽象过程），而是真正的经验，就像医生，20 年和 5 年经验，同样的医学体系对病人的诊断，思维可能完全不一样。20 年的编程（特指非重复的）和 5 年的编程思考总结也全部不一样，良好的抽象前提是知识体系、业务体系、认知体系不断扩充，所以千万不要有程序员 中年危机这种想法，学习性、经验性的时间只会是壁垒，而非累赘。



到实际代码编写，你把哪些代码归类为一个整体，另一些归为另一个整体，而这些整体之间建立交互，抽象良好的代码，意味这 ，你在寻找每一个逻辑的时候，大脑自动设定是这类概念，然后去那个整体代码中寻找，或者你从整理流程中一清二楚全部业务，如同好出的好目录，翻一番目录知道这本书讲什么，而你对哪个地方感兴趣，直接按照页码目录寻找代码即可。抽象的结果、最终是提高效率。
